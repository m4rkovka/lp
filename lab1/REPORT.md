# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Марков А.Н.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список - это последовательность, составленная из произвольного числа элементов. Списки как и все структурные объекты в Прологе можно представлять как двоичное дерево, листьями которого будут элементы списка или пустой список. Таким образом список может быть пустым и не пустым. В первом случае список записывается как атом `[]`. Во втором случае список следует рассматривать как структуру состоящую из головы(первого элемента списка) и хвоста(остальной части списка).

В отличие от списков в императивных языках, в которых список может содержать элементы только одного типа, список в Прологе может включать любые элементы.
В императивных языках можно обрабатывать элементы списка с помощью итераторов, в Прологе же можно использовать только рекурсию, разделяя список на голову и хвост. 

С одной стороны списки в Прологе похожи на бинарные деревья в стандартных языках, т.к. и то, и то требуют грамотного использовния рекурсии. С другой строны логичнее сравнить списки в Прологе с массивами, т.к. они чаще других типов используются в программах.

## Задание 1.1: Предикат обработки списка

`std_count_entry(X, List, N)` - осуществляет подсчет числа вхождений N заданного элемента X в список List c помощью стандартных предикатов.
`count_entry(X, List, N)` - осуществляет подсчет числа вхождений N заданного элемента X в список List без использования стандартных предикатов.

Примеры использования:
```prolog
?- count_entry(a, [p, q, a, a, a, b, a], N).
N = 4.

?- count_entry(0, [0, 0, 1, 2, 0], N).
N = 3.

?- count_entry(0, [1, 2, 3], N).
N = 0 ;
false.

?- std_count_entry(a, [p, q, a, a, a, b, a], N).
N = 4.

?- std_count_entry(0, [0, 0, 1, 2, 0], N).
N = 3.

?- std_count_entry(0, [1, 2, 3], N).
N = 0 .
```

Реализация:
```prolog
count_entry(_,[],0).
count_entry(X,[X | Tail], N) :-
	count_entry(X, Tail , N1),
	N is N1 + 1, !.
count_entry(X, [_ | Tail], N) :-
	count_entry(X, Tail, N).
```

Условия рекурсии:
1) При любом элементе, если список пусто, то число вхождений равно 0.
2) Если элемент совпадает с головой списка, то запускаем рекурсивно count_entry только уже с хвостом списка, полученный результат рекурсии будет содержаться в N1, а изначальное число вхождений будет находиться как сумма N1 + 1, т.к. голова списка уже совпала с элементом.
3) Иначе если элемент не совпал с головой списка, то запускаем рекурсию с хвостом списка, не увеличивая число вхождений.

Реализация:
```prolog
std_count_entry(_, [], 0).
std_count_entry(X, List, N) :-
	my_remove(A, List, NEW),
	A = X,
	std_count_entry(X, NEW, N1),
	N is N1 + 1, !.
std_count_entry(X, List, N) :-
	my_remove(A, List, NEW),
	A \= X,
	std_count_entry(X, NEW, N).
```
С помощью стандартного метода перебора и удаления элемента из списка мы рассматриваем каждый элемент и проверяем на совпадение с нужным элементом, если совпало, то запускаем рекурсию и увеличиваем результата на 1, иначе просто запускаем рекурсию.

## Задание 1.2: Предикат обработки числового списка

`max(X, List)` - осуществляет вычисление максимального элемента без использования стандартных предикатов.
`std_max(X, List)` - осуществляет вычисление максимального элемента с помощью стандартных предикатов.

Примеры использования:
```prolog
?- max(X, [-90, 0, 1, 9, 10]).
X = 10.

?- max(X, [-3, -2, -1]).
X = -1.

?- std_max(X, [0, 0, 0]).
X = 0.

?- std_max(X, [100, 1, 4, 55, 101]).
X = 101 .
```

Реализация:
```prolog
/*Вспомогательный предикат 
для определения максимального элемента.*/
maxhelp(X,[H | Tail]) :-
	X >= H,
	maxhelp(X, Tail).
maxhelp(_, []).

max(X,[X | Tail]) :-
	maxhelp(X, Tail), !.
max(MAX, [_ | Tail]) :-
	max(MAX, Tail). 
```

Рекурсивно сравниваем потенциальный максимальный элемент с головой списка. Если данный элемент не подошел, то запускаем рекурсию для следующего элемента.

Реализация:
```prolog
/*Вспомогательный предикат 
для определения максимального элемента.*/
maxhelp(X,[H | Tail]) :-
	X >= H,
	maxhelp(X, Tail).
maxhelp(_, []).

std_max(X, [X | Tail]) :- 
	maxhelp(X, Tail), !.
std_max(MAX, [X | Tail]) :-
	my_remove(X, [X | Tail], List),
	std_max(MAX, List).
```

Принцип такой же, как и в реализации вычисления максимального элемента без использования стандартных предикатов, только элемент, который не подошел, удаляется с помощью `remove`.

## Задание 2: Реляционное представление данных

Реляционная модель - совокупность данных, состоящая из набора двумерных таблиц. Реляционное представление показывает отношения между объектами. Результат запроса к таким данным - это множество ответов, удовлетворяющих внутренней структуре программы. Вся задача сводится к реализации такой структуры, которая обеспечит выдачу ответов. Преимуществом можно считать относительно простую разработку. Программу можно разбить не маленькие составляющие, с которыми затем просто просто работать. В моем конкретном реляционном представлении необходимые задания очень просто выполнялись с помощью встроенного предиката findall.

Пример two.pl:
```prolog
grade(102,'Петров','Логическое программирование',4).
grade(102,'Петров','Математический анализ',2).
grade(102,'Петров','Функциональное программирование',3).
grade(102,'Петров','Информатика',5).
grade(102,'Петров','Английский язык',5).
grade(102,'Петров','Психология',4).
```

Вариант №2.

Задание 1. Напечатать средний балл для каждого предмета.

`average_mark(Subj, X)` - печатает средний балл X для заданного предмета Subj.

Примеры использования:
```prolog
?- average_mark('Логическое программирование', X).
X = 3.9642857142857144.

?- average_mark('Математический анализ', X).
X = 3.892857142857143.

?- average_mark('Функциональное программирование', X).
X = 3.9642857142857144.

?- average_mark('Информатика', X).
X = 3.9285714285714284.

?- average_mark('Английский язык', X).
X = 3.75.

?- average_mark('Психология', X).
X = 3.9285714285714284.
```

Реализация:
```prolog
/*Сумма N оценок по данному предмету.
(список оценок, сумма оценок)*/
sum_grades([], 0).
sum_grades([H | T], N) :-
	sum_grades(T, M),
	N is H + M.

/*Средний балл для предмета
(название предмета, средняя оценка)*/
average_mark(Subj, X) :-
	findall(Grades, grade(_, _, Subj, Grades), ListGrades),
	sum_grades(ListGrades, AllGrades),
	length(ListGrades, People),
	X is AllGrades / People.
```

Сначала получаем список всех оценок по данному предмету, затем с помощью предиката `sum_grades` подсчитываем сумму всех оценок. Вычисляем длину списка (количество оценок). Потом считаем средний балл (сумму делим на длину списка).

Задание 2. Для каждой группы, найти количество не сдавших студентов.

`failed_exam_group(Gr, Count)` - печатает количество Count не сдавших студентов в группе Gr.

Примеры использования:
```prolog
?- failed_exam_group(101, X).
X = 2.

?- failed_exam_group(102, X).
X = 5.

?- failed_exam_group(103, X).
X = 3.

?- failed_exam_group(104, X).
X = 2.
```

Реализация:
```prolog
/*Удаление повторяющихся элементов в списке
(изначальный список, итоговый список)*/
remove_duplicates([], []) :- !.
remove_duplicates([X|Xs], Ys) :-
    member(X, Xs),
    !, remove_duplicates(Xs, Ys).
remove_duplicates([X|Xs], [X|Ys]) :-
    !, remove_duplicates(Xs, Ys).

/*Количество несдавших студентов в группе
(номер группы, число несдавших)*/
failed_exam_group(Gr, Count) :-
	findall(Fail, grade(Gr, Fail, _, 2), FailList),
	remove_duplicates(FailList, ClearFailList),
	length(ClearFailList, Count).
```

Получаем список всех студентов данной группы получивших 2. Удаляем повторяющиеся оценки, чтобы если один и тот же студент не сдал больше 1 предмета, не считать его дважды. Вычисляем длину полученного списка. Эта длина равна числу не сдавших студентов в данной группе.

Задание 3. Найти количество не сдавших студентов для каждого из предметов.

`failed_exam_subject(Subj, Count)` - печатает количество Count не сдавших студентов предмет Subj.

Примеры использования:
```prolog
?- failed_exam_subject('Логическое программирование', X).
X = 2.

?- failed_exam_subject('Математический анализ', X).
X = 3.

?- failed_exam_subject('Функциональное программирование', X).
X = 1.

?- failed_exam_subject('Информатика', X).
X = 2.

?- failed_exam_subject('Английский язык', X).
X = 4.

?- failed_exam_subject('Психология', X).
X = 1.
```

Реализация:
```prolog
/*Количество несдавших студентов по предмету
(предмет, число несдавших)*/
failed_exam_subject(Subj, Count) :-
	findall(Fail, grade(_, Fail, Subj, 2), FailList),
	length(FailList, Count).
```

Получаем список всех студентов получивших 2 по заданному предмету. Вычисляем длину данного списка. Эта длина равна количеству несдавших студентов по данному предмету.

## Выводы

В императивных языках программирования мы должны определять как получается результат, а в Прологе же - что необходимо сделать. Мы сообщаем Пролог-системе факты и задаем ей вопросы. Хочется отметить, что в Прологе отсутствуют операторы присваивания и указатели, а также что зачастую приходится использовать рекурсию, поэтому было сложно сразу осмыслить его фундаментальные начала, т.к. Пролог требует иного стиля мышления, отказа от стереотипов императивного программирования. Хорошо, что в этой работе была возможность узнать о логическом программировании на простых задачах, т.к. это дало опыт поиска нетривиальных решений обыденных задач.
